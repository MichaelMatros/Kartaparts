// server.js (–∏—Å–ø—Ä–∞–≤–ª—ë–Ω–Ω—ã–π)
// –¢—Ä–µ–±—É–µ—Ç Node >=18 (fetch –≤ –≥–ª–æ–±–∞–ª—å–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏), "type":"module" –≤ package.json –∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ.

import express from 'express';
import fs from 'fs';
import path from 'path';
import multer from 'multer';
import cors from 'cors';
import sharp from 'sharp';
import { pipeline } from '@xenova/transformers';
import cosineSimilarity from 'compute-cosine-similarity';
import crypto from 'crypto';
import 'dotenv/config';

import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// -------------------- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ --------------------
const PARTS_FILE = path.join(__dirname, 'data', 'parts.json');
const EMB_FILE = path.join(__dirname, 'data', 'embeddings.json');
const UPLOADS_DIR = path.join(__dirname, 'uploads');
const PUBLIC_IMAGES_DIR = path.join(__dirname, 'public', 'images');

if (!fs.existsSync(PUBLIC_IMAGES_DIR)) fs.mkdirSync(PUBLIC_IMAGES_DIR, { recursive: true });
if (!fs.existsSync(UPLOADS_DIR)) fs.mkdirSync(UPLOADS_DIR, { recursive: true });

// -------------------- –î–∞–Ω–Ω—ã–µ --------------------
let parts = [];
let partsWithEmbeddings = [];

// -------------------- –ß—Ç–µ–Ω–∏–µ parts.json --------------------
try {
  const raw = fs.readFileSync(PARTS_FILE, 'utf8');
  parts = JSON.parse(raw);
  if (!Array.isArray(parts)) throw new Error('parts.json is not an array');
  console.log(`Loaded parts.json ‚Äî items: ${parts.length}`);
} catch (e) {
  console.error('FATAL: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å/—Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å parts.json:', e.message);
  process.exit(1);
}

// -------------------- Express --------------------
const app = express();
const PORT = process.env.PORT || 5002;
app.use(cors());
app.use(express.json());

// logger
app.use((req, res, next) => {
  console.log(new Date().toISOString(), req.method, req.originalUrl);
  next();
});

// multer –¥–ª—è –∑–∞–≥—Ä—É–∑–æ–∫
const upload = multer({ dest: UPLOADS_DIR });

// –æ—Ç–¥–∞—ë–º —Å—Ç–∞—Ç–∏–∫—É
app.use('/static', express.static(path.join(__dirname, 'public')));

// -------------------- Embedder (–ø–æ–ø—ã—Ç–∫–∞ ViT) --------------------
let embedder = null;
let useFallback = false;

async function initEmbedder() {
  if (embedder || useFallback) return;
  try {
    console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ embedder (google/vit-base-patch16-224) ‚Äî –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –∑–∞–≥—Ä—É–∑–∫–∞ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)...');
    // –ü—ã—Ç–∞–µ–º—Å—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —á–µ—Ä–µ–∑ xenova/transformers (—Å–∫–∞—á–µ—Ç –∏–∑ HuggingFace –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
    embedder = await pipeline('feature-extraction', 'google/vit-base-patch16-224');
    console.log('‚úÖ –õ–æ–∫–∞–ª—å–Ω—ã–π embedder –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω (ViT).');
  } catch (err) {
    console.warn('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å ViT-embedder:', err?.message || err);
    console.warn('–ë—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω Fallback-embedder (–ø—Ä–æ—Å—Ç–æ–π –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è).');
    embedder = null;
    useFallback = true;
  }
}

// Fallback: –ø—Ä–æ—Å—Ç–æ–π —ç–º–±–µ–¥–¥–∏–Ω–≥ ‚Äî grayscale downsample (–≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –æ—Ñ—Ñ–ª–∞–π–Ω)
async function fallbackEmbedding(filePath, size = 64, outDims = 256) {
  // resize to size x size, greyscale, get raw buffer
  const img = await sharp(filePath).resize(size, size, { fit: 'cover' }).removeAlpha().greyscale().raw().toBuffer();
  // img is Uint8Array length = size*size
  const floats = Float32Array.from(img).map(v => v / 255.0); // normalize 0..1

  // reduce to outDims by simple averaging blocks
  const block = Math.floor(floats.length / outDims) || 1;
  const emb = new Array(outDims).fill(0);
  for (let i = 0; i < floats.length; i++) {
    const idx = Math.floor(i / block);
    if (idx < outDims) emb[idx] += floats[i];
  }
  // normalize
  for (let i = 0; i < emb.length; i++) emb[i] = emb[i] / block;
  return emb;
}

// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞—Å—Å–∏–≤ —á–∏—Å–µ–ª (embedding)
async function getImageEmbedding(filePath) {
  // –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞
  if (!fs.existsSync(filePath)) throw new Error('File not found: ' + filePath);

  // –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º embedder –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –æ–±—Ä–∞—â–µ–Ω–∏–∏
  await initEmbedder();

  if (embedder) {
    try {
      // xenova pipeline: –º–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É
      const output = await embedder(filePath);
      // output –º–æ–∂–µ—Ç –±—ã—Ç—å [1, dim] –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ [dim]
      // –ø—Ä–∏–≤–æ–¥–∏–º –∫ –ø–ª–æ—Å–∫–æ–º—É –º–∞—Å—Å–∏–≤—É
      const emb = Array.isArray(output) && Array.isArray(output[0]) ? output[0] : Array.isArray(output) ? output : [];
      return emb.map(x => Number(x)); // ensure numbers
    } catch (err) {
      console.warn('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —ç–º–±–µ–¥–¥–∏–Ω–≥–∞ –æ—Ç ViT –¥–ª—è', filePath, err?.message || err);
      // –ø–∞–¥–∞–µ–º –≤ fallback
      useFallback = true;
      return fallbackEmbedding(filePath);
    }
  } else {
    // fallback
    return fallbackEmbedding(filePath);
  }
}

// -------------------- –£—Ç–∏–ª–∏—Ç–∞: —Å–∫–∞—á–∞—Ç—å –≤–Ω–µ—à–Ω–∏–π URL –≤ –ª–æ–∫–∞–ª—å–Ω—É—é –ø–∞–ø–∫—É --------------------
async function downloadRemoteImage(url) {
  try {
    const parsed = new URL(url);
    const ext = path.extname(parsed.pathname) || '.jpg';
    const hash = crypto.createHash('md5').update(url).digest('hex');
    const filename = `remote-${hash}${ext}`;
    const dest = path.join(PUBLIC_IMAGES_DIR, filename);

    // –µ—Å–ª–∏ —É–∂–µ —Å–∫–∞—á–∞–Ω ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Ç—å
    if (fs.existsSync(dest)) return dest;

    console.log(`–°–∫–∞—á–∏–≤–∞–µ–º —É–¥–∞–ª—ë–Ω–Ω—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É ${url} -> ${dest}`);
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`http ${resp.status}`);

    const arrayBuffer = await resp.arrayBuffer();
    fs.writeFileSync(dest, Buffer.from(arrayBuffer));
    return dest;
  } catch (err) {
    console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ', url, err?.message || err);
    return null;
  }
}

// -------------------- –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤ --------------------
async function buildEmbeddingsIfNeeded() {
  if (partsWithEmbeddings && partsWithEmbeddings.length) {
    console.log('–≠–º–±–µ–¥–¥–∏–Ω–≥–∏ —É–∂–µ –µ—Å—Ç—å ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é.');
    return;
  }

  console.log('üîπ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–æ–∫–∞–ª—å–Ω—ã—Ö —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤ –¥–ª—è parts.json...');
  const results = [];

  for (const p of parts) {
    // –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–ø–∏—Å–∫–∞ –∫–∞—Ä—Ç–∏–Ω–æ–∫ (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç: images array, –∏–Ω–∞—á–µ image)
    const imgs = Array.isArray(p.images) && p.images.length ? p.images : p.image ? [p.image] : [];
    if (!imgs.length) continue;

    for (let img of imgs) {
      try {
        let imagePath;
        if (img.startsWith('http://') || img.startsWith('https://')) {
          // —Å–∫–∞—á–∏–≤–∞–µ–º –≤–Ω–µ—à–Ω—é—é –∫–∞—Ä—Ç–∏–Ω–∫—É –ª–æ–∫–∞–ª—å–Ω–æ
          const downloaded = await downloadRemoteImage(img);
          if (!downloaded) {
            console.log('‚ÑπÔ∏è –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –≤–Ω–µ—à–Ω—é—é –∫–∞—Ä—Ç–∏–Ω–∫—É, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º:', img);
            continue;
          }
          imagePath = downloaded;
          // —Å–æ—Ö—Ä–∞–Ω–∏–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –≤ p.image? (–Ω–µ –º–µ–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ, —Ç–æ–ª—å–∫–æ –¥–ª—è —ç–º–±–µ–¥–¥–∏–Ω–≥–∞)
        } else {
          // –ª–æ–∫–∞–ª—å–Ω—ã–π –ø—É—Ç—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ /public
          imagePath = path.join(__dirname, 'public', img);
        }

        // –ª–æ–≥ –ø—Ä–æ–≤–µ—Ä–∫–∏
        console.log('–ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–∞–π–ª:', imagePath, 'exists=', fs.existsSync(imagePath));
        if (!fs.existsSync(imagePath)) {
          console.log('‚ÑπÔ∏è image file not found:', imagePath);
          continue;
        }

        // –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —ç–º–±–µ–¥–¥–∏–Ω–≥–∞
        const embedding = await getImageEmbedding(imagePath);
        if (!embedding || !Array.isArray(embedding) || embedding.length === 0) {
          console.warn('‚ö†Ô∏è –ü—É—Å—Ç–æ–π —ç–º–±–µ–¥–¥–∏–Ω–≥ –¥–ª—è', p.name || p.id, img);
          continue;
        }

        results.push({ ...p, image: img, embedding });
        console.log('‚úÖ —ç–º–±–µ–¥–¥–∏–Ω–≥ –¥–ª—è', p.name || p.id, img, 'dim=', embedding.length);
      } catch (err) {
        console.warn('‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–º–±–µ–¥–¥–∏–Ω–≥–µ –¥–ª—è', p.name || p.id, err?.message || err);
      }
    }
  }

  partsWithEmbeddings = results;

  try {
    fs.writeFileSync(EMB_FILE, JSON.stringify(partsWithEmbeddings, null, 2), 'utf8');
    console.log(`–°–æ—Ö—Ä–∞–Ω–µ–Ω—ã —ç–º–±–µ–¥–¥–∏–Ω–≥–∏ –≤ ${EMB_FILE}`);
  } catch (e) {
    console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å embeddings.json:', e?.message || e);
  }

  console.log(`–ì–æ—Ç–æ–≤–æ. –≠–º–±–µ–¥–¥–∏–Ω–≥–æ–≤: ${partsWithEmbeddings.length}`);
}

// -------------------- API: –ø–æ–∏—Å–∫ –ø–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é --------------------
app.post(['/search-image', '/api/search-by-image'], upload.single('image') , async (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ error: '–ù–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞' });

    // —É–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ —ç–º–±–µ–¥–¥–∏–Ω–≥–∏ –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω—ã
    if (!partsWithEmbeddings.length) {
      try {
        await buildEmbeddingsIfNeeded();
      } catch (e) {
        console.warn('buildEmbeddingsIfNeeded failed:', e?.message || e);
      }
    }

    // –ø–æ–ª—É—á–∞–µ–º —ç–º–±–µ–¥–¥–∏–Ω–≥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    let userEmb = null;
    try {
      userEmb = await getImageEmbedding(req.file.path);
    } catch (e) {
      console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —ç–º–±–µ–¥–¥–∏–Ω–≥ –¥–ª—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ —Ñ–æ—Ç–æ:', e?.message || e);
    } finally {
      try { fs.unlinkSync(req.file.path); } catch (e) { /* ignore */ }
    }

    if (!userEmb || !partsWithEmbeddings.length) {
      console.log('–í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–µ–º–æ-—Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã (no embeddings).');
      return res.json({ results: parts.slice(0, 6), warning: '–≠–º–±–µ–¥–¥–∏–Ω–≥–∏ –Ω–µ –¥–æ—Å—Ç—É–ø–Ω—ã ‚Äî –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã.' });
    }

    const scored = partsWithEmbeddings
      .map(p => ({ ...p, score: cosineSimilarity(userEmb, p.embedding) }))
      .sort((a, b) => b.score - a.score)
      .slice(0, 6);

    return res.json({ results: scored });
  } catch (err) {
    console.error('/api/search-by-image error:', err);
    return res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è' });
  }
});

// ========== –î—Ä—É–≥–∏–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã ==========
// root
app.get('/', (req, res) => {
  res.send('<html><body><h2>Mock server OK</h2><p>use /api/parts and /api/vin/:vin and POST /api/search-by-image</p></body></html>');
});

// GET /api/parts?q=...
app.get('/api/parts', (req, res) => {
  const q = (req.query.q || '').trim().toLowerCase();
  if (!q) return res.json({ parts });

  const filtered = parts.filter(p =>
    (p.name && p.name.toLowerCase().includes(q)) ||
    (p.brand && p.brand.toLowerCase().includes(q)) ||
    (p.oem && p.oem.toLowerCase().includes(q))
  );
  return res.json({ parts: filtered });
});

// GET /api/vin/:vin
app.get('/api/vin/:vin', (req, res) => {
  const vin = (req.params.vin || '').trim().toUpperCase();
  if (!vin) return res.status(400).json({ error: 'VIN required' });

  if (vin.length !== 17) {
    const q = vin.toLowerCase();
    const filtered = parts.filter(p =>
      (p.name && p.name.toLowerCase().includes(q)) ||
      (p.brand && p.brand.toLowerCase().includes(q)) ||
      (p.oem && p.oem.toLowerCase().includes(q))
    );
    return res.json({ vin, parts: filtered });
  }

  let sum = 0;
  for (let i = 0; i < vin.length; i++) sum = (sum * 31 + vin.charCodeAt(i)) >>> 0;
  const start = parts.length ? sum % parts.length : 0;
  const result = [];
  for (let i = 0; i < Math.min(12, parts.length); i++) result.push(parts[(start + i) % parts.length]);
  return res.json({ vin, parts: result });
});

// GET /api/parts/:id
app.get('/api/parts/:id', (req, res) => {
  const id = Number(req.params.id);
  if (!id) return res.status(400).json({ error: 'Invalid id' });
  const p = parts.find(x => Number(x.id) === id);
  if (!p) return res.status(404).json({ error: 'Part not found' });
  return res.json({ part: p });
});

// single app.listen
app.listen(PORT, async () => {
  console.log(`Server started on http://localhost:${PORT}`);
  await buildEmbeddingsIfNeeded();
});
